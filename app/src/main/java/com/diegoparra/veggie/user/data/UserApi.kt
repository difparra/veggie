package com.diegoparra.veggie.user.data

import android.net.Uri
import com.diegoparra.veggie.core.*
import com.diegoparra.veggie.user.data.UserTransformations.toSignInMethod
import com.diegoparra.veggie.user.entities_and_repo.UserConstants.SignInFields.EMAIL
import com.diegoparra.veggie.user.entities_and_repo.UserConstants.SignInFields.PASSWORD
import com.google.firebase.auth.*
import com.google.firebase.auth.ktx.userProfileChangeRequest
import kotlinx.coroutines.channels.awaitClose
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.callbackFlow
import kotlinx.coroutines.tasks.await
import timber.log.Timber
import javax.inject.Inject

class UserApi @Inject constructor(
    private val auth: FirebaseAuth
) {

    /*  Exceptions:
        https://firebase.google.com/docs/reference/kotlin/com/google/firebase/auth/FirebaseAuth?hl=es-419#createuserwithemailandpassword
     */


    //      ----------      BASIC OPERATIONS        ------------------------------------------------

    fun getCurrentUserAsFlow(): Flow<FirebaseUser?> = callbackFlow {
        val listener = FirebaseAuth.AuthStateListener {
            offer(it.currentUser)
        }
        auth.addAuthStateListener(listener)
        awaitClose { auth.removeAuthStateListener(listener) }
    }

    fun signOut() {
        auth.signOut()
    }

    suspend fun getSignInMethodsForEmail(email: String): Either<Failure, List<String>> {
        return try {
            val result = auth.fetchSignInMethodsForEmail(email).await()
            Timber.d("email: $email - signInMethods = ${result.signInMethods}")
            Either.Right(result.signInMethods ?: listOf())
        } catch (e1: FirebaseAuthInvalidCredentialsException) {
            Either.Left(SignInFailure.WrongInput.Incorrect(field = EMAIL, input = email))
        } catch (e: Exception) {
            Either.Left(Failure.ServerError(e))
        }
    }

    suspend fun updateProfile(
        profileInfoFirebase: ProfileInfoFirebase
    ): Either<Failure, Unit> {
        val name = profileInfoFirebase.name
        val photoUrl = profileInfoFirebase.photoUrl
        if (name == null && photoUrl == null) {
            Timber.w("Nothing updated. Name and photoUrl are null.")
            return Either.Right(Unit)
        }
        return try {
            auth.currentUser
                ?.updateProfile(userProfileChangeRequest {
                    name?.let { displayName = it }
                    photoUrl?.let { photoUri = it }
                })?.await()
            Either.Right(Unit)
        } catch (e1: FirebaseAuthInvalidUserException) {
            //  Email does not exists or has been disabled
            Either.Left(Failure.ServerError(e1))
        } catch (e: Exception) {
            Either.Left(Failure.ServerError(e))
        }
    }


    //      ----------      SIGNIN/UP EMAIL        -------------------------------------------------

    suspend fun createUserWithEmailAndPassword(
        email: String, password: String
    ): Either<Failure, Unit> {
        return try {
            auth.createUserWithEmailAndPassword(email, password).await()
            Either.Right(Unit)
        } catch (e1: FirebaseAuthWeakPasswordException) {
            //  Password is not strong enough
            Either.Left(
                SignInFailure.WrongInput.Unknown(
                    field = PASSWORD,
                    input = password,
                    message = e1.localizedMessage ?: "Password is weak"
                )
            )
        } catch (e2: FirebaseAuthInvalidCredentialsException) {
            //  Email address is malformed
            Either.Left(SignInFailure.WrongInput.Incorrect(field = EMAIL, input = email))
        } catch (e3: FirebaseAuthUserCollisionException) {
            //  Already exists an account with the given email address
            Either.Left(e3.toFailure(EmailAuthProvider.getCredential(email, password)))
        } catch (e: Exception) {
            Either.Left(Failure.ServerError(e))
        }
    }

    suspend fun signInWithEmailAndPassword(email: String, password: String): Either<Failure, Unit> {
        return try {
            //  Equivalent to call signInWithCredential with an EmailAuthCredential generated by EmailAuthProvider.getCredential(String, String)
            auth.signInWithEmailAndPassword(email, password).await()
            Either.Right(Unit)
        } catch (e1: FirebaseAuthInvalidUserException) {
            //  Email does not exists or has been disabled, or user/email does not exist
            Either.Left(
                SignInFailure.WrongInput.Unknown(
                    field = EMAIL,
                    input = email,
                    message = e1.localizedMessage ?: "Email does not exists or has been disabled."
                )
            )
        } catch (e2: FirebaseAuthInvalidCredentialsException) {
            //  Password is incorrect
            Either.Left(SignInFailure.WrongInput.Incorrect(field = PASSWORD, input = password))
        } catch (e3: FirebaseAuthUserCollisionException) {
            //  If there already exists an account with the email address
            Either.Left(e3.toFailure(EmailAuthProvider.getCredential(email, password)))
        } catch (e: Exception) {
            Either.Left(Failure.ServerError(e))
        }
    }

    suspend fun resetPassword(email: String): Either<Failure, Unit> {
        return try {
            auth.sendPasswordResetEmail(email).await()
            Either.Right(Unit)
        } catch (e: Exception) {
            Either.Left(Failure.ServerError(e))
        }
    }


    //      ----------      SIGNIN/UP GOOGLE        ------------------------------------------------

    suspend fun signInWithCredential(credential: AuthCredential): Either<Failure, Unit> {
        return try {
            auth.signInWithCredential(credential).await()
            Either.Right(Unit)
        } catch (e1: FirebaseAuthInvalidUserException) {
            //  If the user account has been disabled or is EmailAuthCredential for non-existent user/email
            Either.Left(Failure.ServerError(e1))
        } catch (e2: FirebaseAuthInvalidCredentialsException) {
            //  If the credential is malformed or has been expired / Password is incorrect
            Either.Left(Failure.ServerError(e2))
        } catch (e3: FirebaseAuthUserCollisionException) {
            //  If there already exists an account with the email address asserted by the credential
            Either.Left(e3.toFailure(credential))
        } catch (e: Exception) {
            Either.Left(Failure.ServerError(e))
        }
    }


    private suspend fun FirebaseAuthUserCollisionException.toFailure(credential: AuthCredential) : Failure {
        val email = this.email!!
        return when(val linkedSignInMethods = getSignInMethodsForEmail(email)){
            is Either.Left -> linkedSignInMethods.a
            is Either.Right -> SignInFailure.WrongSignInMethod.SignInMethodNotLinked(
                email = this.email ?: "",
                signInMethod = credential.signInMethod.toSignInMethod().toString(),
                linkedSignInMethods = linkedSignInMethods.b
            )
        }
    }
}